# 배열
---

## 배열 선언법

배열은 차원과는 무관하게 메모리에 연속 할당된다.

- arr = [0, 0, 0, 0, 0, 0]
- arr = [0] * 6
- arr = list(range(6))
- arr = [0 for _ in range(6)]
- arr = [[i]*4 for i in range(3)] # [[0, 0, 0, 0], [1, 1, 1, 1], [2, 2, 2, 2]]

## 시간복잡도

- 맨 뒤에 삽입하는 경우
    - O(1)
- 맨 앞에 삽입하는 경우
    - 기존 데이터들을 뒤로 한 칸씩 밀어야 하기 때문에 O(N)
- 중간에 삽입하는 경우
    - 삽입한 데이터 뒤에 있는 데이터 개수만큼 밀기 때문에 O(N)
- array.sort() 함수: $O(NlogN)$. 기존 리스트 정렬
- sorted(array): 새로운 리스트 생성. 메모리 낭비될 수도
- set(array) 함수: O(N)

## 모의테스트

- [문제] 두 개 뽑아서 더하기
    - 정수 배열 numbers가 주어집니다. numbers에서 서로 다른 인덱스에 있는 2개의 수를 뽑아 더해 만들 수 있는 모든 수를 배열에 오름차순으로 담아 반환하는 solution( ) 함수를 완성하세요.
    - Solution: 이중 for loop으로 모든 두 수의 합을 구해 array에 append 하고, 이를 list(set(array)로 담아 반환
    - 시간복잡도: $O(N^2log(N^2))$
- [문제] 모의고사
    - 수포자는 수학을 포기한 사람을 줄인 표현입니다. 수포자 삼인방은 모의고사에 수학 문제를 전부 찍으려 합니다. 수포자는 1번 문제부터 마지막 문제까지 다음과 같이 찍습니다.
    
    *• 1번 수포자가 찍는 방식: 1,2,3,4,5,1,2,3,4,5,...
    • 2번 수포자가 찍는 방식: 2,1,2,3,2,4,2,5,2,1,2,3,2,4,2,5,...
    • 3번 수포자가 찍는 방식: 3,3,1,1,2,2,4,4,5,5,3,3,1,1,2,2,4,4,5,5,...*
    
    1번 문제부터 마지막 문제까지의 정답이 순서대로 저장된 배열 answers가 주어졌을 때 가장 많 은 문제를 맞힌 사람이 누구인지 배열에 담아 반환하도록 solution( ) 함수를 작성하세요.
    - Solution: 이중 for loop으로 정답과 수포자들의 답안 비교(패턴은 반복되므로 % 연산자로 비교) 후 정답이 일치할 때마다 +1 score 해줌. max(score) 함수로 최댓값 구해주고 for loop 돌려서 최댓값과 일치하는 수포자들 찾아냄.
    - 시간복잡도: $O(N^2)$
- [문제] 행렬의 곱셈
    - 2차원 행렬 arr1과 arr2를 입력받아 arr1에 arr2를 곱한 결과를 반환하는 solution( ) 함수를 완성하세요.
    - Solution: 삼중 for loop (r1, c2, c1)
    - 시간복잡도: $O(N^3)$
- [문제] 실패율
    - 실패율을 구하는 코드를 완성하세요.
    
    • 실패율 정의 : 스테이지에 도달했으나 아직 클리어하지 못한 플레이어의 수 / 스테이지에 도달한 플레이어의 수
    
    전체 스테이지 개수가 N, 게임을 이용하는 사용자가 현재 멈춰 있는 스테이지의 번호가 담긴 배열 stages가 주어질 때 실패율이 높은 스테이지부터 내림차순으로 스테이지의 번호가 담겨 있는 배열을 반환하도록 solution( ) 함수를 완성하세요.
    - Solution: for loop으로 각 스테이지를 순회하며 실패율 계산. 이때 N번째 스테이지를 클리어한 사용자는 stage가 N+1이므로 배열의 크기를 N+2로 설정함. 이렇게 하면 0번째 인덱스는 사용하지 않아서 낭비라고 생각할 수 있지만, 값 자체를 인덱스로 활용할 수 있어 매우 편리함.
    - 시간복잡도: $O(NlogN)$
- [문제] 방문 길이
    - 명령어가 매개변수 dirs로 주어질 때 게임 캐릭터가 처음 걸어본 길의 길이를 구해 반환하는 solution( ) 함수를 완성하세요. 즉, 중복 경로의 길이를 제외한 움직인 경로의 길이를 반환해야 합니다.
    - Solution: 음수 좌표에 대해 양수화함(-5<x<5 ⇒ 0<x<10). 입력 방향목록에 대해 for loop으로 돌려가며, 범위를 벗어난 명령들은 continue 처리하여 다음 좌표를 set 변수에 담기. set을 사용하면 중복을 제거한 값을 구할 수 있음.
    - 시간복잡도: $O(N)$

## Q&A

> N은 lst의 길이입니다. lst의 중복 원소를 제거하는데 걸리는 시간 복잡도는 O(N)이고, 이를 다시 정렬하는데 걸리는 시간 복잡도는 O(NlogN)이므로 최종 시간 복잡도는 O(NlogN)입니다.
- p.84
> 

왜 O(NlogN)이라는 거?  ⇒  책이 잘못됐을 것임. 베타용이라서… 파이썬의 정렬 함수 sort()와 sorted()는 모두 $O(NlogN)$이 맞음.
