# 해시
*대학시절엔 못 알아들었던 내용들*

---
## 개념 및 정의

- 어떤 값이 저장되는 위치를 어떤 규칙으로 정할 수 있다면! 탐색 없이 바로 찾을 텐데~
- 해시 함수를 사용해 변환한 값을 인덱스로 삼아 빠른 데이터 탐색을 제공하는 자료구조
- Key를 활용한 데이터 탐색

- 단방향으로만 동작함. 즉, 키를 통해 값을 찾을 수 있지만 값을 통해 키를 찾을 수는 없음 → 보안 분야에서 널리 쓰임(비밀번호 관리, DB 인덱싱, 블록체인 etc)
- 시간복잡도: $O(1)$

### 해시 함수

- 코테에서 해시 함수를 직접 구현하라는 문제는 거의 없음
- 파이썬의 딕셔너리 자료형이 해시와 거의 동일하게 동작하므로 해시를 쉽게 사용할 수 있다.
- 해시 원칙 두가지
    - 해시 함수의 변환값은 인덱스로 활용해야 하므로 해시 테이블의 크기를 넘으면 안 됨.
    - 충돌(서로 다른 두 Key에 대해 인덱스값이 동일한 현상) 최소화
- 해시 함수의 종류
    - Modular(나머지를 취하는 연산)
        - *h*(*x*) = *x* mod *k*
        - x는 Key, k는 소수. Key를 소수로 나눈 나머지를 인덱스로 사용하는 것. 소수로 나누는 이유는 충돌이 적기 때문
        - 해시 테이블의 크기는 k. 왜냐하면 k에 대해 모듈러 연산을 했을 때 나올 수 있는 값은 0 ~ (k - 1)이기 때문. 따라서 상황에 따라 아주 많은 데이터를 저장해야 한다면 굉장히 큰 소수가 필요할 수도 있는데, 아쉽게도 매우 큰 소수를 구하는 효율적인 방법은 아직은 없으며 필요한 경우 기계적인 방법으로 구해야 함. 모듈러 방식의 단점이다.
    - 곱셈법
        - *h*(*x*)=(((*x*A*)mod 1)**m*)
        - 모듈러 연산을 활용하지만 소수는 활용하지 않음. m은 최대 버킷의 개수, A는 황금비.
    - 문자열 해싱
        - *hash*(*s*) = (*s*[0]+ *s*[1]* *p* + *s*[2]* *p^*2 .... *s*[*n-*1]* *p^(n-1)*) mod *m*
        - p는 31이고, m은 해시 테이블 최대 크기.
        - p﻿를 31로 정한 이유는 홀수이면서 메르센 소수이기 때문.
        메﻿르센 소수는 일반적으로 $2^N-1$ 형식으로 표시할 수 있는 숫자 중 소수인 수를 말합니다. 메르센소수는 해시에서 충돌을 줄이는 데 효과적이라는 연구 결과가 있음
        - 오버플로우가 발생하기 쉬우므로 수정식을 사용함. 수정 전과 후의 결과값은 같음.
            - *hash*(*s*) = (*s*[0]%m+ *s*[1]* *p*%m **+ *s*[2]* *p^*2%m .... *s*[*n-*1]* *p^(n-1)*%m) mod *m*

## 충돌 처리

- 체이닝
    - 충돌이 발생하면 해당 버킷에 링크드리스트로 같은 해시값을 가지는 데이터를 연결
    - 그러나 충돌이 많아지면 그만큼 링크드리스트의 길이가 길어지고, 다른 해시 테이블의 공간은 덜 사용하 므로 공간 활용성이 떨어짐
- 개방 주소법
    - 충돌이 발생하면 빈 버킷을 찾아 충돌값을 삽입
    - 이 방법은 해시 테이블을 최대한 활용함 → 메모리 효율화
        - 선형 탐사 방식
            - *h*(*k*,*i*) = (*h*(*k*) + *i*) mod *m*
            - 다른 빈 버킷을 찾을 때까지 일정 간격으로 이동함. m은 수용할 수 있는 최대 버킷.
            - 하지만 충돌 발생 시 1칸씩 이동하며 해시 테이블 빈 곳에 값을 넣으면 해시 충돌이 발생한 값끼리 모이는 영역이 생긴다. 이를 클러스터cluster를 형성한다고 하는데, 이런 군집이 생기면 해시값은 겹칠 확률이 더 올라간다. 따라서 제곱수만큼 이동하며 탐사하는 방법도 있다.
        - 이중 해싱 방식
            - *h*(*k*,*i*) = *h*1(*k*) + *i*h*2(*k*) mod *m*
            - 클러스터 형성 가능성을 많이 낮출 수 있음.